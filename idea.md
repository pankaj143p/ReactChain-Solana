# MetaStor v0 Development Guide: Bare Minimum MVP within 10 Days

## Introduction

This document provides a detailed guide to developing the MetaStor project as a bare minimum viable product (MVP) version 0 (v0) within a strict 10-day timeline using a naive approach. The focus is on simplicity, leveraging the existing tech stack (Next.js, Solana, IPFS, Prisma, TailwindCSS) to create a functional prototype that demonstrates core decentralized storage concepts without advanced features. We prioritize essential functionalities: user authentication via Solana wallet, file upload to IPFS with metadata in PostgreSQL, simulated payment via Solana token transfer, and a basic dashboard for viewing files. Complex elements like a full marketplace, multiple providers, end-to-end encryption beyond basic hashing, global networks, flexible pricing, or real-time analytics are omitted to meet the deadline. This naive implementation assumes local development, minimal error handling, and a single "provider" model with fixed pricing (e.g., 0.001 SOL per upload). The guide is structured flow-wise, detailing data flows, service interactions, and small implementation nuances to ensure clarity and reproducibility.

## Project Scope and Limitations

In this v0, MetaStor acts as a proof-of-concept where users connect their Solana wallet, upload files to a local IPFS node, pay a fixed fee via Solana devnet, and view their files via metadata stored in a local PostgreSQL database. Limitations include: no true decentralization beyond IPFS (database and API are centralized), potential file loss if IPFS pins expire, no user registration beyond wallet connection, basic security (e.g., no JWT for sessions, rely on wallet signatures), and local-only setup without production deployment. This approach reduces scope to fit 10 days, assuming 8-10 hours daily for a solo developer familiar with the stack. If issues arise (e.g., Solana network delays), use mocks like local keypairs for transactions.

## Tech Stack and Setup Details

The tech stack remains as specified: Frontend with Next.js 14 (App Router), TailwindCSS, and shadcn/ui; Backend via Next.js API routes; PostgreSQL with Prisma ORM; IPFS via local daemon; Solana via @solana/web3.js. Use Turborepo for monorepo management. For setup: On Day 1, clone the repo from https://github.com/kushwahramkumar2003/MetaStor, run `npm install`, copy `apps/web/.env.example` to `.env`, and populate with `DATABASE_URL=postgresql://user:pass@localhost:5432/metastor`, `IPFS_API_URL=http://localhost:5001`, `SOLANA_RPC_URL=https://api.devnet.solana.com`, and a platform wallet public key (generate via Solana CLI: `solana-keygen new`). Install Solana CLI globally if needed (`cargo install solana-cli`), create a devnet wallet, and fund it via airdrop (`solana airdrop 2`). Start IPFS daemon (`ipfs daemon`) in a separate terminal. Run `npx prisma migrate dev` to set up the database schema. Small detail: Ensure PostgreSQL is running locally (e.g., via Docker: `docker run -p 5432:5432 -e POSTGRES_PASSWORD=pass postgres`), and handle any port conflicts by checking `netstat`. Test the setup by running `npm run dev` and verifying the web app loads at http://localhost:3000.

## Services Overview

We define four core services for minimal complexity: 1) Frontend Service (Next.js web app for UI and user interactions); 2) Backend API Service (Next.js API routes for logic); 3) Database Service (PostgreSQL for metadata); 4) IPFS Service (local node for storage). A fifth external service is Solana Blockchain (public devnet RPC). Why these? The Frontend isolates user-facing code; Backend handles sensitive operations like file buffering; Database enables fast querying (IPFS/Solana aren't query-friendly); IPFS provides the decentralized storage hook; Solana adds blockchain payment simulation. No additional services (e.g., separate auth microservice) to avoid overhead—everything communicates synchronously via HTTP or direct library calls. Communication: Frontend to Backend via fetch/Axios over localhost:3000/api; Backend to Database via Prisma client (TCP to localhost:5432); Backend to IPFS via ipfs-http-client (HTTP to localhost:5001); Frontend/Backend to Solana via Web3.js (HTTPS to RPC endpoint). All calls are naive: blocking where possible, with async/await for I/O, no retries beyond basic try-catch, and errors logged to console/alerted to user.

## Prisma Schema Details

Define a simple schema in `apps/web/prisma/schema.prisma`: models include `User` (id: Int @id @default(autoincrement), pubKey: String @unique, createdAt: DateTime @default(now())) and `File` (id: Int @id @default(autoincrement), userId: Int, fileName: String, cid: String, timestamp: DateTime @default(now()), paid: Boolean @default(false), @relation(fields: [userId], references: [id])). This captures essentials: link files to users via pubKey, store IPFS CID for retrieval. Small nuances: Use String for pubKey (base58 encoded), Boolean for paid status to track transaction confirmation. Run `npx prisma generate` after changes. In code, import PrismaClient and instantiate once globally to avoid connection leaks.

## Data Flow: User Wallet Connection

The flow starts with user authentication via Solana wallet. In the Frontend (e.g., `apps/web/app/layout.tsx` or a dedicated component), integrate @solana/wallet-adapter-react with providers like Phantom. On page load, render a "Connect Wallet" button; upon click, call `connect()` which triggers wallet selection and signs a message for verification. Data flow: User clicks → Frontend hooks trigger wallet adapter → Wallet signs nonce (e.g., "Login to MetaStor") → Frontend sends signed message to Backend /api/auth via POST { pubKey, signature, nonce } → Backend verifies signature using @solana/web3.js (PublicKey.verify), creates/updates User in Database if valid → Returns { success: true, user: { pubKey } } → Frontend stores pubKey in localStorage or React state for session. Small details: Handle disconnects by clearing state; no expiration on sessions (naive); if verification fails, alert "Invalid signature"; use base58 encoding for pubKeys throughout.

## Data Flow: File Upload

Core feature: Uploading a file. User selects file via <input type="file"> in Frontend dashboard (post-connection), clicks "Upload" → Frontend creates FormData with file and pubKey → POST to Backend /api/upload. Backend receives request (using Next.js req.formData()), extracts file buffer → Uses ipfs-http-client to call ipfs.add(buffer, { pin: true }) → Gets CID → Creates metadata { userPubKey: pubKey, fileName: originalName, cid, timestamp: new Date() } → Prisma.file.create({ data: { ...metadata, user: { connect: { pubKey } } } }) → Prepares Solana transaction: Use web3.js to create Transaction with SystemProgram.transfer({ fromPubkey: new PublicKey(pubKey), toPubkey: new PublicKey(platformWallet), lamports: 1000000 }) → Serialize transaction → Return { txSerialized: tx.serialize().toString('base64'), fileId: newFile.id }. Frontend decodes, deserializes tx, prompts wallet to signAndSendTransaction → On success, gets signature → POST to /api/confirm { fileId, signature } → Backend verifies signature via connection.getSignatureStatuses, updates Prisma.file.update({ where: { id: fileId }, data: { paid: true } }) → Returns success. Small details: Limit file size to 1MB via frontend validation (file.size < 1e6); handle IPFS add errors (e.g., daemon not running: alert "Start IPFS"); use devnet for cheap tx (lamports = 0.001 SOL); poll confirmation every 1s up to 30s; if tx fails, delete metadata to avoid orphans.

## Data Flow: File Retrieval and Dashboard

For viewing: User loads dashboard → Frontend GET /api/files?pubKey=... → Backend Prisma.file.findMany({ where: { user: { pubKey }, paid: true }, select: { fileName, cid, timestamp } }) → Returns array → Frontend renders list with links like `https://ipfs.io/ipfs/${cid}` or embeds via <img src={`/api/proxy?cid=${cid}`}> for proxying. Implement proxy route in Backend: /api/proxy?cid → ipfs.cat(cid) → Stream response with correct MIME. Small details: Sort by timestamp desc; paginate naively (limit 10); if no files, show "No uploads yet"; handle CID not found by alerting "File unpinned or lost" (naive, no auto-repin).

## Error Handling and Edge Cases

Naive but comprehensive: In all flows, wrap in try-catch; Frontend shows toasts (use shadcn/ui) for errors like "Upload failed: Network error"; Backend returns 500 with { error: msg }; Specifics: Wallet not installed → Redirect to Phantom download; Insufficient SOL → Alert post-tx attempt; Database unique violations (e.g., duplicate pubKey) → Handled by Prisma; IPFS offline → Check via ipfs.id() on startup; Solana congestion → Increase poll timeout. Test edge: Upload empty file (reject if size=0), special chars in filename (sanitize with slugify), multiple uploads (ensure tx per upload).

## Development Timeline and Commands

Days 1-2: Setup, schema, IPFS/Wallet integration. Days 3-4: Frontend UI (upload form, dashboard). Days 5-6: Backend APIs (upload, confirm, files). Days 7-8: End-to-end testing, fix flows. Days 9-10: Polish (styles, comments), update docs. Commands: `npm run dev` for local; `npm run build` for checks; `npm run lint` for code quality. Small tip: Use console.log liberally for debugging; commit often.

## Future Enhancements

Post-v0: Add smart contracts for escrow, multi-provider matching via Solana programs, decentralize DB with Tableland, full encryption with lit-protocol, production deploy with Vercel/Docker. This MVP validates the stack for iteration.
